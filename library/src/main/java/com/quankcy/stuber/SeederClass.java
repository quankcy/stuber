/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.quankcy.stuber;

import java.lang.reflect.Field;

public class SeederClass {

    /*
    Algorytm:

    - Podaj klase
    - Sparsuj klase pod katem :
        - typow prostych i ich obiektowych odpowiedninkow
        - klas  z tym samym root packagem lub podanym patternem - to nasze zaleznosci do uzupelnienia
            - Utworz graf - uwazaj na cyklicznosc - po wykryciu cyklicznosci nalezy ja pominac ( nie ma sensu wracac do sparsowanej juz raz klasy )
            - Uzupelniamy klasy w kierunku od wierzcholkow do roota
    - Wszystkie pola majace annotacje wymagaja uzupelnienia zgodne z annotacja ( annotacja do ustalenia )


    Podsumowaujac algoryrm:

    - zdobywamy wiedze o kazdej klasie jak ja uzupelnic ze wzgledu na dane
    - zdobywamy wiedze o zaleznosciach jakie sa miedzy klasami, aby potworzyc referencje


    Kolejnosc developmentu:

    - Pojedyncza klasa bez zaleznosci - sparsowanie
        - Stworzenie seeda
    - Pojedyncza klasa z pojedyncza zaleznoscia
    - Pojedyncza klasa z podwojna zaleznoscia
    - Cykliczna zaleznosc miedzy 2 klasami
    - Pojedyncza klasa z podwojna zaleznoscia - klasy maja cykliczna zaleznoscs


    Pomysly:

    - Moze warto wygenerowac seedery na ksztalt JpaRepositoryImpl albo MapStruct mapperow - duza oszczednosc czasu - gotowe klasy bedace seedami
    - Moze warto ustalic glebokosc seedowania danych ( n-depth )
     */



    static void parseClass(Class clazz) {
        Field[] declaredFields = clazz.getDeclaredFields();

        declaredFields.toString();

//        List<Field> fieldsToStub = Arrays.stream(declaredFields)
//                .filter(Stuber::filterByStubAnnotation)
//                .collect(Collectors.toList());
    }

    private static boolean filterByStubAnnotation(Field declaredField) {
        return declaredField.getAnnotation(SeedMapper.class) != null;
    }

}
